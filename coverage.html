<!DOCTYPE html>
<html>

<head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>tinytime: Go Coverage Report</title>
        <style>
                body {
                        background: black;
                        color: rgb(80, 80, 80);
                }

                body,
                pre,
                #legend span {
                        font-family: Menlo, monospace;
                        font-weight: bold;
                }

                #topbar {
                        background: black;
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        height: 42px;
                        border-bottom: 1px solid rgb(80, 80, 80);
                }

                #content {
                        margin-top: 50px;
                }

                #nav,
                #legend {
                        float: left;
                        margin-left: 10px;
                }

                #legend {
                        margin-top: 12px;
                }

                #nav {
                        margin-top: 10px;
                }

                #legend span {
                        margin: 0 5px;
                }

                .cov0 {
                        color: rgb(192, 0, 0)
                }

                .cov1 {
                        color: rgb(128, 128, 128)
                }

                .cov2 {
                        color: rgb(116, 140, 131)
                }

                .cov3 {
                        color: rgb(104, 152, 134)
                }

                .cov4 {
                        color: rgb(92, 164, 137)
                }

                .cov5 {
                        color: rgb(80, 176, 140)
                }

                .cov6 {
                        color: rgb(68, 188, 143)
                }

                .cov7 {
                        color: rgb(56, 200, 146)
                }

                .cov8 {
                        color: rgb(44, 212, 149)
                }

                .cov9 {
                        color: rgb(32, 224, 152)
                }

                .cov10 {
                        color: rgb(20, 236, 155)
                }
        </style>
</head>

<body>
        <div id="topbar">
                <div id="nav">
                        <select id="files">

                                <option value="file0">github.com/cdvelop/tinytime/frontWasm.go (96.3%)</option>

                                <option value="file1">github.com/cdvelop/tinytime/shared.go (100.0%)</option>

                        </select>
                </div>
                <div id="legend">
                        <span>not tracked</span>

                        <span class="cov0">not covered</span>
                        <span class="cov8">covered</span>

                </div>
        </div>
        <div id="content">

                <pre class="file" id="file0" style="display: none">//go:build wasm
// +build wasm

package tinytime

import (
        "syscall/js"

        . "github.com/cdvelop/tinystring"
)

// timeClient implements TimeProvider for WASM/JS environments using the JavaScript Date API.
type timeClient struct {
        dateCtor js.Value
}

// NewTimeProvider returns the correct implementation for WASM.
func NewTimeProvider() TimeProvider <span class="cov8" title="1">{
        return &amp;timeClient{
                dateCtor: js.Global().Get("Date"),
        }
}</span>

func (tc *timeClient) UnixNano() int64 <span class="cov8" title="1">{
        jsDate := tc.dateCtor.New()
        msTimestamp := jsDate.Call("getTime").Float()
        // Convert milliseconds to nanoseconds
        return int64(msTimestamp) * 1000000
}</span>

func (tc *timeClient) FormatDate(value any) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case int64:<span class="cov8" title="1">
                jsDate := tc.dateCtor.New(float64(v) / 1e6)
                return jsDate.Call("toISOString").String()[0:10]</span>
        case string:<span class="cov8" title="1">
                // Validate date format: YYYY-MM-DD (10 chars with dashes at positions 4 and 7)
                if len(v) == 10 &amp;&amp; v[4] == '-' &amp;&amp; v[7] == '-' </span><span class="cov8" title="1">{
                        return v
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func (tc *timeClient) FormatTime(value any) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case int64:<span class="cov8" title="1"> // UnixNano
                jsDate := tc.dateCtor.New(float64(v) / 1e6)
                hours := jsDate.Call("getUTCHours").Int()
                minutes := jsDate.Call("getUTCMinutes").Int()
                seconds := jsDate.Call("getUTCSeconds").Int()
                return Fmt("%02d:%02d:%02d", hours, minutes, seconds)</span>
        case int16:<span class="cov8" title="1"> // Minutes since midnight
                hours := v / 60
                minutes := v % 60
                return Fmt("%02d:%02d", hours, minutes)</span>
        case string:<span class="cov8" title="1">
                if Count(v, ":") &gt;= 1 </span><span class="cov8" title="1">{
                        return v
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func (tc *timeClient) FormatDateTime(value any) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case int64:<span class="cov8" title="1">
                jsDate := tc.dateCtor.New(float64(v) / 1e6)
                iso := jsDate.Call("toISOString").String()
                return iso[0:10] + " " + iso[11:19]</span>
        case string:<span class="cov8" title="1">
                // Validate datetime format: YYYY-MM-DD HH:MM:SS (19 chars)
                if len(v) == 19 &amp;&amp; v[4] == '-' &amp;&amp; v[7] == '-' &amp;&amp; v[10] == ' ' &amp;&amp; v[13] == ':' &amp;&amp; v[16] == ':' </span><span class="cov8" title="1">{
                        return v
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func (tc *timeClient) FormatDateTimeShort(value any) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case int64:<span class="cov8" title="1">
                jsDate := tc.dateCtor.New(float64(v) / 1e6)
                iso := jsDate.Call("toISOString").String()
                return iso[0:10] + " " + iso[11:16]</span>
        case string:<span class="cov8" title="1">
                // Validate short datetime format: YYYY-MM-DD HH:MM (16 chars)
                if len(v) == 16 &amp;&amp; v[4] == '-' &amp;&amp; v[7] == '-' &amp;&amp; v[10] == ' ' &amp;&amp; v[13] == ':' </span><span class="cov8" title="1">{
                        return v
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func (tc *timeClient) ParseDate(dateStr string) (int64, error) <span class="cov8" title="1">{
        // Validate format: YYYY-MM-DD (10 chars with dashes at positions 4 and 7)
        if len(dateStr) != 10 || dateStr[4] != '-' || dateStr[7] != '-' </span><span class="cov8" title="1">{
                return 0, Errf("invalid date format: %s (expected YYYY-MM-DD)", dateStr)
        }</span>

        <span class="cov8" title="1">jsDate := tc.dateCtor.New(dateStr + "T00:00:00Z")
        if jsDate.Call("toString").String() == "Invalid Date" </span><span class="cov0" title="0">{
                return 0, Errf("invalid date format: %s", dateStr)
        }</span>

        // Verify date components match (JS Date auto-corrects invalid dates like Feb 30)
        <span class="cov8" title="1">year := jsDate.Call("getUTCFullYear").Int()
        month := jsDate.Call("getUTCMonth").Int() + 1
        day := jsDate.Call("getUTCDate").Int()
        expected := Fmt("%04d-%02d-%02d", year, month, day)
        if expected != dateStr </span><span class="cov8" title="1">{
                return 0, Errf("invalid date: %s (auto-corrected to %s)", dateStr, expected)
        }</span>

        <span class="cov8" title="1">ms := jsDate.Call("getTime").Float()
        return int64(ms) * 1000000, nil</span>
}

func (tc *timeClient) ParseTime(timeStr string) (int16, error) <span class="cov8" title="1">{
        return parseTime(timeStr)
}</span>

func (tc *timeClient) ParseDateTime(dateStr, timeStr string) (int64, error) <span class="cov8" title="1">{
        if len(timeStr) == 5 </span><span class="cov8" title="1">{
                timeStr += ":00"
        }</span>
        <span class="cov8" title="1">isoStr := dateStr + "T" + timeStr + "Z"
        jsDate := tc.dateCtor.New(isoStr)
        if jsDate.Call("toString").String() == "Invalid Date" </span><span class="cov8" title="1">{
                return 0, Errf("invalid date/time format: %s %s", dateStr, timeStr)
        }</span>
        <span class="cov8" title="1">ms := jsDate.Call("getTime").Float()
        return int64(ms) * 1000000, nil</span>
}

func (tc *timeClient) IsToday(nano int64) bool <span class="cov8" title="1">{
        jsDate := tc.dateCtor.New(float64(nano) / 1e6)
        now := tc.dateCtor.New()
        return jsDate.Call("toDateString").String() == now.Call("toDateString").String()
}</span>

func (tc *timeClient) IsPast(nano int64) bool <span class="cov8" title="1">{
        return nano &lt; tc.UnixNano()
}</span>

func (tc *timeClient) IsFuture(nano int64) bool <span class="cov8" title="1">{
        return nano &gt; tc.UnixNano()
}</span>

func (tc *timeClient) DaysBetween(nano1, nano2 int64) int <span class="cov8" title="1">{
        return daysBetween(nano1, nano2)
}</span>

// WasmTimer implements Timer for WASM using setTimeout
type WasmTimer struct {
        id     int
        active bool
        jsFunc js.Func // Store to release later
        f      func()  // Store callback to execute
}

func (wt *WasmTimer) Stop() bool <span class="cov8" title="1">{
        if !wt.active </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">js.Global().Call("clearTimeout", wt.id)
        wt.active = false
        wt.jsFunc.Release() // Free memory
        return true</span>
}

func (wt *WasmTimer) Fire() <span class="cov8" title="1">{
        if !wt.active </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">wt.active = false
        wt.jsFunc.Release() // Free memory after execution
        if wt.f != nil </span><span class="cov8" title="1">{
                wt.f()
        }</span>
}

func (tc *timeClient) AfterFunc(milliseconds int, f func()) Timer <span class="cov8" title="1">{
        wt := &amp;WasmTimer{
                active: true,
                f:      f,
        }

        wt.jsFunc = js.FuncOf(func(this js.Value, args []js.Value) any </span><span class="cov0" title="0">{
                wt.Fire()
                return nil
        }</span>)

        <span class="cov8" title="1">wt.id = js.Global().Call("setTimeout", wt.jsFunc, milliseconds).Int()
        return wt</span>
}
</pre>

                <pre class="file" id="file1" style="display: none">package tinytime

import (
        . "github.com/cdvelop/tinystring"
)

// parseTime is a shared helper function for parsing time strings ("HH:MM" or "HH:MM:SS").
func parseTime(timeStr string) (int16, error) <span class="cov8" title="1">{
        parts := Convert(timeStr).Split(":")
        if len(parts) &lt; 2 </span><span class="cov8" title="1">{
                return 0, Errf("invalid time format: %s", timeStr)
        }</span>
        <span class="cov8" title="1">hours, err := Convert(parts[0]).Int()
        if err != nil || hours &lt; 0 || hours &gt; 23 </span><span class="cov8" title="1">{
                return 0, Errf("invalid hours: %s", parts[0])
        }</span>
        <span class="cov8" title="1">minutes, err := Convert(parts[1]).Int()
        if err != nil || minutes &lt; 0 || minutes &gt; 59 </span><span class="cov8" title="1">{
                return 0, Errf("invalid minutes: %s", parts[1])
        }</span>
        <span class="cov8" title="1">return int16(hours*60 + minutes), nil</span>
}

// daysBetween is a shared helper function for calculating the number of full days between two timestamps.
func daysBetween(nano1, nano2 int64) int <span class="cov8" title="1">{
        // 86400000000000 nanoseconds in a day
        const nanosInDay = 86400000000000
        return int((nano2 - nano1) / nanosInDay)
}</span>
</pre>

        </div>
</body>
<script>
        (function () {
                var files = document.getElementById('files');
                var visible;
                files.addEventListener('change', onChange, false);
                function select(part) {
                        if (visible)
                                visible.style.display = 'none';
                        visible = document.getElementById(part);
                        if (!visible)
                                return;
                        files.value = part;
                        visible.style.display = 'block';
                        location.hash = part;
                }
                function onChange() {
                        select(files.value);
                        window.scrollTo(0, 0);
                }
                if (location.hash != "") {
                        select(location.hash.substr(1));
                }
                if (!visible) {
                        select("file0");
                }
        })();
</script>

</html>